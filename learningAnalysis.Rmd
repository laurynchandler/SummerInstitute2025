---
title: "learningAnalysis_07_24"
output: html_document
date: "2025-07-24"
---



```{r load packages, echo=FALSE, include=FALSE}
library(tidyverse)
library(lme4)
library(lmerTest)
library(performance)
library(patchwork)
library(emmeans)
library(corrplot)
library(Hmisc)
library(broom)
library(corrr)
library(reshape2)
```


```{r load data, message=FALSE, warning=FALSE}
# learning data
df_learn <- read.csv('data/learning.csv')
df_learn <- df_learn %>%
  filter(trial < 91) %>%
  mutate(scaledTrial = as.numeric(scale(trial)),
         scaledLogTrial = as.numeric(scale(log(trial))), 
         cueIdx = factor(cueIdx, levels=c(1,2,3), labels=c('non-neutral1', 'non-neutral2', 'neutral'))) %>%
  group_by(subID) %>%
  mutate(scaledImgLockedRT = as.numeric(scale(imgLockedRT))) %>%
  ungroup()

# estimates data
df_est <- read.csv('data/estimates.csv')
df_est <- df_est %>%
  group_by(subID) %>%
  mutate(zCueConf = as.numeric(scale(cueConfidence)),
         cueCorr = cor(trueCue, subjectiveCue),
         cueDiff = subjectiveCue - trueCue) %>%
  ungroup()

# inference data
df_inf <- read.csv('data/inference_test_tidy.csv') %>% select(-X)
df_inf <- df_inf %>%
  group_by(subID) %>%
  mutate(zconf = scale(confidence),
         zconfRT = scale(confRT))
```

# slope of regression lines during learning: all subjects

## predicting z-scored image-locked RT using `trueCue * scaledLogTrial`, controlling for response finger using `imageIdx` as a regressor
```{r}
# fit model
m <- lm(scaledImgLockedRT ~ scaledLogTrial * trueCue + imageIdx, data = df_learn)
# plot trends
emmip(m, trueCue ~ scaledLogTrial, CIs=T, at=list(trueCue = unique(df_learn$trueCue),
                                                    scaledLogTrial = range(df_learn$scaledLogTrial))) + 
  geom_hline(yintercept=mean(df_learn$scaledImgLockedRT,na.rm=T)) + labs(y='scaledimgLockedRT', title = 'fitted trends: scaledimgLockedRT ~ scaledLogTrial * trueCue')
# view summary
summary(m) 
```
- significant main effect of trueCue: people are faster for more predictive trueCues
- potentially trending interaction between trial & trueCue: people get (marginally) faster for more predictive trueCues over the course of learning

# empirical plots: scaledImgLockedRT by scaledLogTrial
```{r}
df_learn %>%
  mutate(trueCue = factor(trueCue))%>%
  ggplot(aes(x=scaledLogTrial, y=scaledImgLockedRT, color=trueCue, fill=trueCue)) +
  theme_bw() + facet_wrap(~subID, nrow=4) + geom_hline(yintercept = 0, color='gray30') +
  geom_point(size=0.5, alpha=0.7) + stat_smooth(method='lm', linewidth=0.75)
```

# fit regression model for each subject, extract simple slopes for trueCue
```{r}
trueCue_coefs <- list()
trueCue_trends <- list()

for(sub_id in unique(df_learn$subID)) {
  df_sub <- df_learn %>% filter(subID == sub_id)
  model_sub <- lm(scaledImgLockedRT ~ scaledLogTrial * trueCue + imageIdx, data = df_sub)

  # Get tidy results with coefficients, t-values, and p-values
  tidy_true <- tidy(model_sub)
  # Add subject ID
  tidy_true$subID <- sub_id
  
  # get the emtrends
  trends <- emtrends(model_sub, ~ trueCue, var='scaledLogTrial', at=list(trueCue=unique(df_sub$trueCue))) %>% 
    as.data.frame() %>% mutate(subID = sub_id)

  # Add to lists
  trueCue_coefs[[length(trueCue_coefs) + 1]] <- tidy_true
  trueCue_trends[[length(trueCue_trends) + 1]] <- trends
}

# Combine all results
df_trueCue_coefs <- bind_rows(trueCue_coefs)
df_trueCue_trends <- bind_rows(trueCue_trends)

# Reorder columns to put subID first
# df_trueCue_coefs <- df_trueCue_coefs[, c("subID", "term", "estimate", "std.error", "statistic", "p.value")]
```
 
 
# make simple plots of correlations of interest
## correlation between learning interaction coefficient & cueCorr
```{r}
# make dataframe with just the interaction coefficients
df_trueCue_interaction_coefs <- df_trueCue_coefs %>% filter(term == 'scaledLogTrial:trueCue') 

# plot
df_est %>% select(cueCorr, subID) %>% unique() %>%
  left_join(., df_trueCue_interaction_coefs, by='subID') %>%
  ggplot(aes(x=estimate, y=cueCorr)) + theme_bw() + geom_point() +
  stat_smooth(method='lm') + labs(x='interaction coefficient value')

# fit linear model
df_est %>% select(cueCorr, subID) %>% unique() %>%
  left_join(., df_trueCue_interaction_coefs, by='subID') %>%
  lm(cueCorr ~ estimate, .) %>% summary()
```

## correlation between simple slope for each trueCue and the average cueDiff for that trueCue
```{r}

df_cueDiffs <- df_est %>% group_by(subID, trueCue) %>% summarise(meanDiff = mean(cueDiff, na.rm=T))

# make a plot
df_cueDiffs %>% left_join(., df_trueCue_trends, by=c('subID', 'trueCue')) %>%
  mutate(trueCue = factor(trueCue, levels=c(0.5, 0.65, 0.8))) %>%
  ggplot(., aes(x=scaledLogTrial.trend, y=meanDiff, color=trueCue, fill=trueCue)) +
  theme_bw() + geom_point() + stat_smooth(method = 'lm') + labs(y = 'average cueDiff', x = 'simple effect of cue')

# fit a linear model
df_cueDiffs %>% left_join(., df_trueCue_trends, by=c('subID', 'trueCue')) %>%
  lm(meanDiff ~ scaledLogTrial.trend*trueCue, .) %>% summary()
```


## individual correlations with different outcome variables of interest
```{r}
coef_trueCue <- df_trueCue_stats %>%
  select(subID, term, estimate) %>%
  pivot_wider(names_from = term, values_from = estimate)

coef_cueIdx <- df_cueIdx_stats %>%
  select(subID, term, estimate) %>%
  pivot_wider(names_from = term, values_from = estimate)

trueCue_full <- inner_join(coef_trueCue, df_est, by = "subID")
cueIdx_full  <- inner_join(coef_cueIdx,  df_est, by = "subID")

cor_test_matrix <- function(full_df, outcome_vars, exclude = "subID") {
  coef_vars <- setdiff(names(full_df), c(exclude, outcome_vars))
  
  #numeric columns
  full_df[coef_vars] <- lapply(full_df[coef_vars], function(x) as.numeric(as.character(x)))
  full_df[outcome_vars] <- lapply(full_df[outcome_vars], function(x) as.numeric(as.character(x)))
  
  cor_matrix <- matrix(NA, nrow = length(coef_vars), ncol = length(outcome_vars),
                       dimnames = list(coef_vars, outcome_vars))
  p_matrix <- cor_matrix
  
  for (coef in coef_vars) {
    for (outcome in outcome_vars) {
      x <- full_df[[coef]]
      y <- full_df[[outcome]]
      valid <- complete.cases(x, y)
      if (sum(valid) >= 3) {  
        test <- cor.test(x[valid], y[valid])
        cor_matrix[coef, outcome] <- test$estimate
        p_matrix[coef, outcome] <- test$p.value
      }
    }
  }
  
  list(correlation = cor_matrix, p.value = p_matrix)
}

outcome_vars <- c("cueDiff", "cueCorr", "cueConfidence", "subjectiveCue")

trueCue_corrs <- cor_test_matrix(trueCue_full, outcome_vars)
cueIdx_corrs  <- cor_test_matrix(cueIdx_full,  outcome_vars)

trueCue_corrs$correlation     # Correlations: trueCue model
trueCue_corrs$p.value         # P-values

cueIdx_corrs$correlation      # Correlations: cueIdx model
cueIdx_corrs$p.value          # P-values

# Save correlation matrices
# write.csv(trueCue_corrs$correlation, "trueCue_correlations_matrix.csv", row.names = TRUE)
# write.csv(cueIdx_corrs$correlation,  "cueIdx_correlations_matrix.csv",  row.names = TRUE)

# Save p-value matrices
# write.csv(trueCue_corrs$p.value, "trueCue_pvalues_matrix.csv", row.names = TRUE)
# write.csv(cueIdx_corrs$p.value,  "cueIdx_pvalues_matrix.csv",  row.names = TRUE)

```

# aggregate datasets
merging datasets by subject ( thought it would be interesting to compare variables in different stages of testing) 
```{r}
df_est_agg <- df_est %>%
  group_by(subID) %>%
  summarise(
    subjectiveCue = mean(subjectiveCue, na.rm = TRUE),
    cueConfidence = mean(cueConfidence, na.rm = TRUE),
    cueCorr = first(cueCorr), 
    cueDiff = mean(cueDiff, na.rm = TRUE),
    .groups = 'drop'
  )

#df_inf aggregate
df_inf_agg <- df_inf %>%
  group_by(subID) %>%
  summarise(
    inference_zRT = mean(zlogRT, na.rm = TRUE),
    confidence_rating = mean(confidence, na.rm = TRUE),
    confidence_zRT = mean(zconfRTs, na.rm = TRUE),
    .groups = 'drop'
  )

combined_data <- df_est_agg %>%
  full_join(df_inf_agg, by = "subID")

```


## correlation martix
```{r}
# Select variables
outcome_vars <- combined_data %>%
  select(subjectiveCue, cueConfidence, cueDiff, cueCorr, 
         inference_zRT, confidence_rating, confidence_zRT) 

# Correlation matrix
cor_matrix <- cor(outcome_vars, use = "complete.obs")

# re order variables
desired_order <- c("subjectiveCue", "cueDiff", "cueCorr", "cueConfidence","confidence_rating", "confidence_zRT","inference_zRT")

# Reorder correlation matrix
cor_matrix_reordered <- cor_matrix[desired_order, desired_order]

print(cor_matrix_reordered)
#compute p vals
p_matrix <- outcome_vars %>% 
  as.matrix() %>%
  rcorr()
```

## correlation map
```{r}
# Convert correlation matrix to long format
cor_melted <- data.frame(
  Var1 = rep(rownames(cor_matrix_reordered), ncol(cor_matrix_reordered)),
  Var2 = rep(colnames(cor_matrix_reordered), each = nrow(cor_matrix_reordered)),
  value = as.vector(cor_matrix_reordered)
)

# factor levels to order variables
cor_melted$Var1 <- factor(cor_melted$Var1, levels = desired_order)
cor_melted$Var2 <- factor(cor_melted$Var2, levels = rev(desired_order))


# Create heatmap
ggplot(cor_melted, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = round(value, 2)), color = "black", size = 3) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), name = "Correlation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Correlation Heatmap", x = "", y = "") 
```